---
layout: post
title:  "Extract Generic Functionalities"
date:   2022-10-26 16:00:00 +0200
---
How often did you face the code mixing some generic functionality with your use-case code?

# Problem Statement
The starting point is presented below.
The method calculates weighted averge of user's stocks. The weighted average is calculates 

```java
    public Map<StockSymbol, BigDecimal> weightedAverageOfStocks(List<UserStockTransaction> stocks) {
        Map<StockSymbol, List<UserStockTransaction>> stocksBySymbol = new HashMap<>();
        for (UserStockTransaction stock : stocks) {
            stocksBySymbol.computeIfAbsent(stock.getSymbol(), stockSymbol -> new ArrayList<>()).add(stock);
        }
        Map<StockSymbol, BigDecimal> result = new HashMap<>();
        for (Map.Entry<StockSymbol, List<UserStockTransaction>> entry : stocksBySymbol.entrySet()) {
            BigDecimal totalPrice = entry.getValue().stream()
                    .map(userStock -> userStock.getPricePerShare().multiply(userStock.getQuantity()))
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            BigDecimal totalQuantity = entry.getValue().stream()
                    .map(userStock -> userStock.getQuantity())
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            result.put(entry.getKey(), totalPrice.divide(totalQuantity, MathContext.DECIMAL128));
        }
        return result;
    }
```

The very first thing I notice is lack of 

Ideally when reading such high-level method I would like to have main steps 

```java
    public Map<StockSymbol, BigDecimal> weightedAverageOfStocks(List<UserStockTransaction> stocks) {
        // groups UserStock by StockSymbol
        // for each group calculates weighted average
        // returns weighted average per StockSymbol
    }
```
Extract method 
```java
    public Map<StockSymbol, BigDecimal> weightedAverageOfStocks(List<UserStockTransaction> stocks) {
        Map<StockSymbol, List<UserStockTransaction>> stocksBySymbol = new HashMap<>();
        for (UserStockTransaction stock : stocks) {
            stocksBySymbol.computeIfAbsent(stock.getSymbol(), stockSymbol -> new ArrayList<>()).add(stock);
        }
        Map<StockSymbol, BigDecimal> result = new HashMap<>();
        for (Map.Entry<StockSymbol, List<UserStockTransaction>> entry : stocksBySymbol.entrySet()) {
            result.put(entry.getKey(), calculateWeightedAverage(entry.getValue()));
        }
        return result;
    }
```
Improve by declarative approach


```java
    public Map<StockSymbol, BigDecimal> weightedAverageOfStocks(List<UserStockTransaction> stocks) {
        return stocks.stream().collect(
                groupingBy(UserStockTransaction::getSymbol,
                        collectingAndThen(toList(), this::calculateWeightedAverage))
        );
    }
```


Let's back to weighted average calculate method

```java
    private BigDecimal calculateWeightedAverage(List<UserStockTransaction> stocks) {
        BigDecimal totalPrice = stocks.stream()
                .map(userStock -> userStock.getPricePerShare().multiply(userStock.getQuantity()))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        BigDecimal totalQuantity = stocks.stream()
                .map(userStock -> userStock.getQuantity())
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        return totalPrice.divide(totalQuantity, MathContext.DECIMAL128);
    }
```

```java
    private BigDecimal calculateWeightedAverage(List<UserStockTransaction> stocks) {
        List<WeightedValue> weightedValues = stocks.stream()
                .map(stock -> new WeightedValue(stock.getPricePerShare(), stock.getQuantity()))
                .collect(toList());
        return weightedAverage(weightedValues);
    }
```

```java
public class Statistics {
    private Statistics() {
    }

    public static BigDecimal weightedAverage(List<WeightedValue> values) {
        BigDecimal totalValues = values.stream()
                .map(value -> value.getValue().multiply(value.getWeight()))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        BigDecimal totalWeight = values.stream()
                .map(value -> value.getWeight())
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        return totalValues.divide(totalWeight, MathContext.DECIMAL128);
    }
}

public final class WeightedValue {
    private final BigDecimal value;
    private final BigDecimal weight;

    public WeightedValue(BigDecimal value, BigDecimal weight) {
        this.value = value;
        this.weight = weight;
    }

    public BigDecimal getValue() {
        return value;
    }

    public BigDecimal getWeight() {
        return weight;
    }
}
```
Lambda to simplify
```java
    private BigDecimal calculateWeightedAverage(List<UserStockTransaction> stocks) {
        return weightedAverage(stocks, stock -> new WeightedValue(stock.getPricePerShare(), stock.getQuantity()));
    }
```

```java
    private BigDecimal calculateWeightedAverage(List<UserStockTransaction> stocks) {
        return weightedAverage(stocks, UserStockTransaction::getPricePerShare, UserStockTransaction::getQuantity);
    }
```

End up
```java
    public Map<StockSymbol, BigDecimal> weightedAverageOfStocks(List<UserStockTransaction> stocks) {
        return stocks.stream().collect(
                groupingBy(UserStockTransaction::getSymbol,
                        collectingAndThen(toList(), this::calculateWeightedAverage))
        );
    }

    private BigDecimal calculateWeightedAverage(List<UserStockTransaction> stocks) {
        return weightedAverage(stocks, UserStockTransaction::getPricePerShare, UserStockTransaction::getQuantity);
    }
```
```java
public class Statistics {
    private Statistics() {
    }

    public static <T> BigDecimal weightedAverage(List<T> values, Function<T, BigDecimal> toValue, Function<T, BigDecimal> toWeight) {
        BigDecimal totalValues = values.stream()
                .map(domain -> toValue.apply(domain).multiply(toWeight.apply(domain)))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        BigDecimal totalWeight = values.stream()
                .map(domain -> toWeight.apply(domain))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        return totalValues.divide(totalWeight, MathContext.DECIMAL128);
    }
}
```
collectors
```java
    public Map<StockSymbol, BigDecimal> weightedAverageOfStocks(List<UserStockTransaction> stocks) {
        return stocks.stream().collect(
                groupingBy(UserStockTransaction::getSymbol,
                        weightedAverage(UserStockTransaction::getPricePerShare, UserStockTransaction::getQuantity))
        );
    }
```
```java
public class StatisticsCollectors {
    private StatisticsCollectors() {
    }

    public static <T> Collector<T, ?, BigDecimal> weightedAverage(Function<T, BigDecimal> toValue, Function<T, BigDecimal> toWeight) {
        return collectingAndThen(toList(), list -> Statistics.weightedAverage(list, toValue, toWeight));
    }
}
```

STOP



How often did you converted one model to another to just call the desired functionality?

Quite often you have some generic functionality which is used across your application code.
The generic functionality utilizes a problem-specific model which is relevant for the problem it solves and
independent of other higher-level functionalities.

To make this abstract statements more concrete let's suppose that the generic functionality
is weighed average calculation. It provides its own model (API) which could look like:

<pre>
<code>
public class WeighedAverage {
    public static BigDecimal calculate(List<WeightedValue> values) {
        //
    }
}

public final class bond.WeightedValue {
    private final BigDecimal value;
    private final BigDecimal weight;

    public bond.WeightedValue(BigDecimal value, BigDecimal weight) {
        this.value = value;
        this.weight = weight;
    }

    public BigDecimal getValue() {
        return value;
    }

    public BigDecimal getWeight() {
        return weight;
    }
}
</code>
</pre>
In the user portfolio module you calculate the weighted average for the user bond.stocks. To achieve it
one must convert from UserStock to bond.WeightedValue model, which is a little cumbersome leading to more
complex logic that it could be.
<pre>
<code>
class UserPortfolio {
    private static BigDecimal bond.weightedAverage(List<UserStock> bond.stocks) {
        List<WeightedValue> values = bond.stocks.stream()
                .map(stock -> new bond.WeightedValue(stock.price, stock.quantity))
                .collect(toList());
        return WeighedAverage.calculate(values);
    }
}
</code>
</pre>
The post is going to answer how to make the weighted average API more streamlined and convenient for the client by getting
rid of the explicit conversion step. The inspiration may come from Collections.sort(List, Comparator) method and is based on lambda.

In case of our example, the initial bond.weightedAverage method can be compacted to the following code in which the lambda
expression acts as a bridge between one API and another.
<pre>
<code>
    private static BigDecimal bond.weightedAverage(List<UserStock> bond.stocks) {
        return WeighedAverage.calculate(bond.stocks, stock -> new bond.WeightedValue(stock.getPrice(), stock.getQuantity()));
    }
</code>
</pre>
It can be even further simplified a bit.
<pre>
<code>
    private static BigDecimal bond.weightedAverage(List<UserStock> bond.stocks) {
        return WeighedAverage.calculate(bond.stocks, UserStock::getPrice, UserStock::getQuantity);
    }
</code>
</pre>